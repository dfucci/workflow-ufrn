package org.domain.model;

import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Embeddable;
import javax.persistence.Entity;
import javax.persistence.Transient;

import org.hibernate.annotations.Immutable;
import org.jboss.seam.Component;
import org.jboss.seam.annotations.Name;
import org.jboss.seam.contexts.Contexts;

import br.gov.dpf.epol.model.Papel;
import br.gov.dpf.epol.session.EGPService;
import br.gov.dpf.epol.session.PapelService;

@Name("user")
@Entity
public class User {

	@Column(name = "ID_SERVIDOR")
	private Integer id;

	@Transient
	private Cargo cargo;
	
	@Transient
	private Pessoa pessoa;
	
	@Transient
	private Unidade unidade;
	
	@Transient
	private boolean lazyLoaded = false;
	
	public Servidor() {}
	
	public Servidor(Integer id) {
		this.setId(id);
	}
	
	public Servidor(Integer id, Cargo cargo, Pessoa pessoa,
			Unidade unidade){
		this.setId(id);
		this.setCargo(cargo);
		this.setPessoa(pessoa);
		this.setUnidade(unidade);
		this.lazyLoaded = true;
	}
	
	/**
	 * Fornece os superiores de um Servidor, são eles: os responsáveis pela
	 * sua unidade e os responsáveis pelas Unidades Gestoras, recursivamente.
	 * Além dos responsáveis pelas unidades citadas, tem-se o também o Corregedor.
	 * 
	 * @return Os servidores que são superiores ao Servidor.
	 */
	@Transient
	public List<Servidor> getSuperiores() {
		Set<Servidor> superiores = new LinkedHashSet<Servidor>();
		
		// O loop para quando a unidade é null ou a unidade é a Unidade Gestora
		// dela mesma, isto acontece quando uma unidade não possui Unidade Gestora.
		boolean cont = true;
		Unidade unidade = getUnidade();
		while (unidade != null && cont) {
			cont = ! unidade.equals(unidade.getUnidadeGestora());

			if (unidade.getCorregedor() != null) {
				superiores.add(unidade.getCorregedor());
			}
			superiores.addAll(unidade.getResponsaveis());
			
			unidade = unidade.getUnidadeGestora();
		}
		
		superiores.remove(this);
		return new LinkedList<Servidor>(superiores);
	}
	
	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Cargo getCargo() {
		this.lazyLoad();
		return cargo;
	}

	public void setCargo(Cargo cargo) {
		this.cargo = cargo;
	}
	
	public Pessoa getPessoa() {
		this.lazyLoad();
		return pessoa;
	}
	
	public void setPessoa(Pessoa pessoa) {
		this.pessoa = pessoa;
	}
	
	public Unidade getUnidade() {
		this.lazyLoad();
		return unidade;
	}

	public void setUnidade(Unidade unidade) {
		this.unidade = unidade;
	}

	private void lazyLoad() {
		if (!lazyLoaded && this.getId() != null
				&& Contexts.isApplicationContextActive()) {
			EGPService egpBean = (EGPService) Component
					.getInstance("egpService");
			Servidor servidorDTO = egpBean.getServidor(this.getId());

			this.setId(servidorDTO.getId());
			this.setCargo(servidorDTO.getCargo());
			this.setPessoa(servidorDTO.getPessoa());
			this.setUnidade(servidorDTO.getUnidade());
			this.lazyLoaded = true;
		}
	}
	
	@Override
	public int hashCode() {
		this.lazyLoad();
		final int prime = 31;
		int result = 1;
		result = prime * result + ((getCargo() == null) ? 0 : getCargo().hashCode());
		result = prime * result + ((getPessoa() == null) ? 0 : getPessoa().hashCode());
		result = prime * result + ((getUnidade() == null) ? 0 : getUnidade().hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		this.lazyLoad();
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof Servidor))
			return false;
		Servidor other = (Servidor) obj;
		if (getCargo() == null) {
			if (other.getCargo() != null)
				return false;
		} else if (!getCargo().equals(other.getCargo()))
			return false;
		if (getPessoa() == null) {
			if (other.getPessoa() != null)
				return false;
		} else if (!getPessoa().equals(other.getPessoa()))
			return false;
		if (getUnidade() == null) {
			if (other.getUnidade() != null)
				return false;
		} else if (!getUnidade().equals(other.getUnidade()))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return getCargo().getCargoAbreviado() + " - " + getPessoa().getNomeFantasia() + " - " + getPessoa().getMatricula();
	}
	
	//TODO Alterar o método de resolução se é Corregedor da unidade
	public boolean isCorregedor(){
		return  this.id == 6;
	}
	
	/**
	 * Método utilizado na View de Definição de Permissões de Acesso,
	 * que apresenta uma listagem de Servidores e necessita de uma
	 * descrição.
	 * 
	 * @author Samuel Queiroz
	 * @since 0.4a
	 * 
	 * @return Resumo dos dados do Servidor.
	 */
	@Transient
	public String getDados() {
		return this.toString();
	}
	
	/**
	 * Método auxiliar para ordenar objetos do tipo java.util.List e 
	 * listar servidores em lista de distribuição.
	 * 
	 * @author Diego Santos
	 * 
	 * @return Nome Pessoa
	 */
	public String getNomePessoa(){
		return getPessoa().getNome();
	}
	
	/**
	 * Método auxiliar para listar Matriculas de Servidores.
	 * 
	 * @author Diego Santos
	 * 
	 * @return Matricula Pessoa
	 */
	public Integer getMatricula(){
		return getPessoa().getMatricula();
	}
	
	/**
	 * Metodo auxiliar para recuperar os papeis que o servidor exerce
	 * 
	 * @Return papeis
	 */
	
	public String getPapeis(){
		String retorno = "";
		PapelService buscaPapel = (PapelService) Component.getInstance("papelService");
		Papel papelPesquisadoAnalista = buscaPapel.getPapel(this.unidade, this,"Analista");
		Papel papelPesquisadoParecerista = buscaPapel.getPapel(this.unidade, this,"Parecerista");
		Papel papelPesquisadoDistribuidor = buscaPapel.getPapel(this.unidade, this,"Distribuidor");
		Papel papelPesquisadoResponsavel = buscaPapel.getPapel(this.unidade, this,"Responsavel");
		
		if(papelPesquisadoAnalista != null)
			retorno += "Analista, ";
		
		if(papelPesquisadoParecerista != null)
			retorno += "Parecerista, ";
		
		if(papelPesquisadoDistribuidor != null)
			retorno += "Distribuidor, ";
		if(papelPesquisadoResponsavel != null)
			retorno += "Responsavel, ";
		
		
			
		if(retorno.length() > 0)
			return retorno.substring(0,retorno.length() - 2);
		else
			return retorno;
		
	}
	 
}
